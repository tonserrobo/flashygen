[
  {
    "front": "What is auto in C++ type deduction?",
    "back": "auto is a keyword that enables automatic type inference by the compiler:\n\n```cpp\nauto x = 42;         // int\nauto y = 3.14;       // double\nauto str = \"hello\";  // const char*\n```\n\nThe compiler determines the type based on the initializer.",
    "type": "recall"
  },
  {
    "front": "How does decltype work in type deduction?",
    "back": "decltype extracts the type of an expression without evaluating it:\n\n```cpp\nint x = 10;\ndecltype(x) y = 20;  // y is an int\ndecltype(x + y) z;   // z is an int\n```\n\nIt's useful for complex type inference in templates and generic programming.",
    "type": "conceptual"
  },
  {
    "front": "When would you use auto&&  in type deduction?",
    "back": "auto&& enables perfect forwarding and can bind to both lvalues and rvalues:\n\n```cpp\ntemplate<typename T>\nvoid func(T&& arg) {\n\tauto&& forwarded = std::forward<T>(arg);\n\t// Can forward argument preserving its value category\n}\n```\n\nAllows preserving the original value category of arguments.",
    "type": "application"
  },
  {
    "front": "What are the limitations of auto type deduction?",
    "back": "auto has several type deduction limitations:\n\n```cpp\n// Removes references\nauto x = someRef;    // Loses reference\n\n// Doesn't work with braced initialization\nauto y{42};         // Doesn't deduce int\n\n// Strips const/volatile qualifiers\nauto z = const_var; // Loses const\n```\n\nRequires careful understanding of type inference rules.",
    "type": "comparison"
  },
  {
    "front": "How do you use decltype(auto) in C++14?",
    "back": "decltype(auto) preserves the exact type, including references:\n\n```cpp\ntemplate<typename T>\ndecltype(auto) func(T&& arg) {\n\treturn std::forward<T>(arg);\n}\n\n// Preserves original type exactly\n```\n\nUseful for perfect return type deduction in templates.",
    "type": "command"
  },
  {
    "front": "What is move semantics in C++?",
    "back": "Move semantics allows efficient transfer of resources without deep copying:\n\n```cpp\nstd::vector<int> createVector() {\n\tstd::vector<int> vec{1, 2, 3};\n\treturn vec;  // Uses move constructor\n}\n\nauto newVec = createVector();  // Moves resources\n```\n\nPrevents unnecessary copying of large objects.",
    "type": "conceptual"
  },
  {
    "front": "How do you implement a move constructor?",
    "back": "Move constructor transfers resources and leaves source object in valid state:\n\n```cpp\nclass MyClass {\n\tstd::vector<int> data;\npublic:\n\t// Move constructor\n\tMyClass(MyClass&& other) noexcept :\n\t\tdata(std::move(other.data)) {}\n};\n```\n\nUses std::move to transfer resources efficiently.",
    "type": "command"
  },
  {
    "front": "What is std::move and how does it work?",
    "back": "std::move converts an lvalue to an rvalue reference, enabling move semantics:\n\n```cpp\nstd::string s1 = \"hello\";\nstd::string s2 = std::move(s1);  // Transfers ownership\n\n// s1 is now in valid but unspecified state\n```\n\nDoesn't actually move anything, just casts to rvalue reference.",
    "type": "application"
  },
  {
    "front": "Difference between lvalue and rvalue references?",
    "back": "Lvalue references bind to named objects, rvalue references bind to temporary objects:\n\n```cpp\nint x = 10;        // x is an lvalue\nint& lref = x;     // Lvalue reference\nint&& rref = 42;   // Rvalue reference to temporary\n```\n\nRvalue references enable move semantics and perfect forwarding.",
    "type": "comparison"
  },
  {
    "front": "What is perfect forwarding in templates?",
    "back": "Perfect forwarding preserves the value category of arguments using universal references:\n\n```cpp\ntemplate<typename T>\nvoid wrapper(T&& arg) {\n\tinner(std::forward<T>(arg));\n}\n```\n\nAllows seamless argument passing while maintaining original reference type.",
    "type": "conceptual"
  }
]